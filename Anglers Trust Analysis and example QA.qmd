---
title: "Epicollect5 Automated QAQC example"
format: html
editor: visual
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(message=FALSE,warning=FALSE, echo=FALSE, cache=TRUE)
```

The Angling Trust Water Quality Monitoring Network uses Epicollect5 as a data collection platform. This platform enables data to be share data via manual download, visualises sample points on a map in app and importantly, provides an API: enabling data to consistantly be shared in a uniform format and in near-real-time, making it prime for automation.

In this example, we will explore the Angling Trust Water Quality Monitoring Network.

This data includes the following parameters (the whole suite is not always measured at each site):

-   Upload date
-   Sampler Name
-   Site Name
-   Project title
-   River Name (doesn't match up with WFD)
-   Time of sample
-   Date
-   Weather at time of sample
-   Electrical Conductivity (not sure of units)
-   Phosphate (ppm)
-   Temperature (°C)
-   Nitrate (ppm)
-   River level (relative)
-   Sample Accuracy
-   Presence of algal blooms
-   Presence of pollution
-   Photo
-   Latitude
-   Longitude
-   Easting
-   Northing
-   UTM Zone

```{r}
source("Extraction_Transform.R")

```

### Example map of national nitrate data

The below map shows Nitrate (ppm) as a mean per site plotted nationally. It covers an arbitrary timespan, a mean is calculated from `r range(df$Date)[1]` to today's date.
```{r}


pal1 <- colorBin(palette = "viridis", domain=df$Mean_Nitrate, 
                 bins = c(0,0.5,1,2,3,4,5,10,15,20,30,40))

#Plot mean nitrate on a map, experimental so only covers an arbitrary timespan

leaflet(df) %>% 
  addProviderTiles(providers$Esri) %>% 
  addCircleMarkers(lng= ~df$Longitude, 
                   lat= ~df$Latitude, 
                   col=~pal1(df$Mean_Nitrate), 
                   radius=5, 
                   opacity = 1,
                   popup = paste0("Site: ",df$Site_Name,"<br> ",
                                  "Mean Nitrate (ppm): ",df$Mean_Nitrate),
                                  "Sample Count: ", df$Count) %>% 
  addLegend(pal = pal1, values = ~Mean_Nitrate, opacity = 0.7,
            title="Mean Nitrate (ppm)") %>% 
  addControl(paste0("Mean Nitrate (ppm) from ", range(df$Date)[1], " to ", 
                    range(df$Date)[2]),
             position = "bottomleft")

```

By having access to our partner's data the EA can increase our intelligence on our catchments and be more economical in targeting our data.

By having access to data through an API, the EA can access data in near-real-time, this means environmental decisions can be based on the latest intelligence from our partners.

It also means we aren't blindsided by data from our partners and moves towards building environmental surveillance. As an example, the below table shows the data collected this morning:

```{r}

# Calculate two weeks ago

  twowkago <- Sys.Date()- 14
  
#Map for samples added in last two weeks.


Last2 <- df %>% 
  filter(Date >= twowkago & Date <= Sys.Date())


pal1 <- colorBin(palette = "YlRdOr", domain=Last2$Phos_ppm, 
                 bins = c(0, 0.1, 0.2,0.3,0.4,0.5,1,2,3,4,5))

#Plot mean nitrate on a map, experimental so only covers an arbitrary timespan

leaflet(Last2) %>% 
  addProviderTiles(providers$Esri) %>% 
  addCircleMarkers(lng= ~Longitude, 
                   lat= ~Latitude, 
                   col=~pal1(Mean_Nitrate), 
                   radius=5, 
                   opacity = 1,
                   popup = paste0("Site: ", Last2$Site_Name,"<br> ",
                                  "Phosphate (ppm): ",Last2$Phos_ppm),
                                  "Collected at: ", Last2$created_at) %>% 
  addLegend(pal = pal1, values = ~Mean_Nitrate, opacity = 0.7,
            title="Mean Nitrate (ppm)") %>% 
  addControl(paste0("Mean Nitrate (ppm) from ", range(df$Date)[1], " to ", 
                    range(df$Date)[2]),
             position = "bottomleft")

```

### Example QAQC

#### Screening for Zeros

Note Ammonia has a lot of null values

```{r screening for zeroes}
for (x in 1:dim(df)[2]){
  print(paste0(colnames(df)[x], " has ", sum(is.na(df[x])), " zeroes"))
}

```

#### Applying a confidence classification to data when temperatures are \< 10°C and river levels are "High". High river levels are interpreted to result in turbid conditions which can skew colorimeter results.

```{r}

# Plots of national variation in data for Cit Sci QAQC

df$confidence <- ifelse(df$`Temp_°C` < 10 & df$River_level == "High", "Low", "Normal")


high_ri <-  df %>% filter(River_level == "High") # Storm events
norm_ri <- df %>% filter(River_level != "High")

par(mfrow = c(2,2))


# Below here, I'm guessing by trying to gra

high_river_level <- summary(high_ri)
norm_river_level <- summary(norm_ri)

stats_comp <- data.frame(Stats= row.names(high_river_level), 
                         as.vector(high_river_level), 
                         as.vector(norm_river_level))


hist(df$Nitrate_ppm, breaks = 100, main = "Nitrate_ppm", xlab = "Nitrate_ppm", col = "lightblue", border = "black")
hist(df$Phos_ppm, breaks = 100, main = "Phos_ppm", xlab = "Phos_ppm", col = "lightblue", border = "black")



library(ggplot2)

# The 
ggplot(high_ri, aes(x = Phos_ppm)) +
  geom_histogram(bins = 100, fill = "lightblue", color = "black") +
  labs(title = "Phos_ppm high river level", x = "Phos_ppm") +
  scale_y_continuous(limits = c(0, 200))+coord_flip()
ggplot(norm_ri, aes(x = Phos_ppm)) +
  geom_histogram(bins = 100, fill = "lightblue", color = "black") +
  labs(title = "Phos_ppm normal river level", x = "Phos_ppm") +
  scale_y_continuous(limits = c(0, 200))+coord_flip()

# these could be nice violin plots


library(ggplot2)

# Create the plot with both violin and boxplot layers
ggplot(high_ri, aes(x = "", y = Phos_ppm)) +
  geom_violin(fill = "#6f9969", color = "black", alpha = 0.5) + # Violin plot with some transparency
  geom_boxplot(width = 0.2, color = "black", fill = "#efc86e") + # Boxplot on top
  labs(title = "Phos_ppm Distribution at High River Level", x = "", y = "Phos_ppm") +
  scale_y_continuous(limits = c(0, 2.5)) # Adjust the y-axis limits as needed

ggplot(norm_ri, aes(x = "", y = Phos_ppm)) +
  geom_violin(fill = "#aab5d5", color = "black", alpha = 0.5) + # Violin plot with some transparency
  geom_boxplot(width = 0.2, color = "black", fill = "#efc86e") + # Boxplot on top
  labs(title = "Phos_ppm Distribution at Normal or Low River Level", x = "", y = "Phos_ppm") +
  scale_y_continuous(limits = c(0, 2.5)) # Adjust the y-axis limits as needed



df$River_level <- as.factor(df$River_level)

str(df)
df$River_level <- as.factor(df$River_level)


# Violin plot of phos


# See distribution change at different river leves and therein we're inferring turbidity levels.

ggplot(df, aes(x = "", y = Phos_ppm)) +
  geom_violin(aes(fill = River_level), color = "black", alpha = 0.5) + # Violin plot with some transparency
  geom_boxplot(width = 0.2, color = "black", aes(fill = River_level), alpha = 0.7) + # Boxplot on top
  geom_text(data = df_counts, aes(x = "", y = -Inf, label = paste("Count: ", count)), vjust = -0.5, hjust = 0.5, size = 4) + # Add counts below the x-axis
  labs(title = "Ammon_ppm Distribution by River Level", x = "", y = "Ammon_ppm") +
  scale_y_continuous(limits = c(0, 2.5)) + # Adjust the y-axis limits as needed
  facet_wrap(~ River_level, scales = "free_y") + # Create facets for each level
  theme_minimal() + # Use a minimal theme for a cleaner look
  theme(legend.position = "none") # Remove legend to avoid clutter




```

The purpose of these plots are to understand how conditions may impact data

```{r}

df_counts_Phos <- df %>%
  group_by(River_level, Phos_ppm) %>%
  summarise(count = n()) %>% 
  mutate(
    tot_count = sum(count)
  )

df_counts_Amm <- df %>%
  group_by(River_level, Ammon_ppm) %>%
  summarise(count = n()) %>% 
  mutate(
    tot_count = sum(count)
  )

library(ggplot2)
library(dplyr)

# See distribution change at different river leves and therein we're inferring turbidity levels.
ggplot(df, aes(x = "", y = Ammon_ppm)) +
  geom_violin(aes(fill = River_level), color = "black", alpha = 0.5) + # Violin plot with some transparency
  geom_boxplot(width = 0.2, color = "black", aes(fill = River_level), alpha = 0.7) + # Boxplot on top
  geom_text(data = df_counts_Amm, aes(x = "", y = -Inf, label = paste("Count: ", tot_count)), vjust = -0.4, hjust = 0.5, size = 3) + # Add counts below the x-axis
  labs(title = "Ammonia Distribution by River Level", x = "", y = "Ammon_ppm") +
  scale_y_continuous(limits = c(0, 2.5)) + # Adjust the y-axis limits as needed
  facet_wrap(~ River_level, scales = "free_y") + # Create facets for each level
  theme_minimal() + # Use a minimal theme for a cleaner look
  theme(legend.position = "none") # Remove legend to avoid clutter


ggplot(df, aes(x = "", y = Phos_ppm)) +
  geom_violin(aes(fill = River_level), color = "black", alpha = 0.5) + # Violin plot with some transparency
  geom_boxplot(width = 0.2, color = "black", aes(fill = River_level), alpha = 0.7) + # Boxplot on top
  geom_text(data = df_counts_Phos, aes(x = "", y = -Inf, label = paste("Count: ", tot_count)), vjust = -0.4, hjust = 0.5, size = 3) + # Add counts below the x-axis
  labs(title = "Phosphate Distribution by River Level", x = "", y = "Phosphate (ppm)") +
  scale_y_continuous(limits = c(0, 2.5)) + # Adjust the y-axis limits as needed
  facet_wrap(~ River_level, scales = "free_y") + # Create facets for each level
  theme_minimal() + # Use a minimal theme for a cleaner look
  theme(legend.position = "none") # Remove legend to avoid clutter

# See distribution change at different river leves and therein we're inferring turbidity levels.
ggplot(df, aes(x = "", y = Ammon_ppm)) +
  geom_violin(aes(fill = River_level), color = "black", alpha = 0.5) + # Violin plot with some transparency
  geom_boxplot(width = 0.2, color = "black", aes(fill = River_level), alpha = 0.7) + # Boxplot on top
  geom_text(data = df_counts_Amm, aes(x = "", y = -Inf, label = paste("Count: ", tot_count)), vjust = -0.4, hjust = 0.5, size = 3) + # Add counts below the x-axis
  labs(title = "Ammonia Distribution by River Level", x = "", y = "Ammon_ppm") +
  scale_y_continuous(limits = c(0, 2.5)) + # Adjust the y-axis limits as needed
  facet_wrap(~ River_level, scales = "free_y") + # Create facets for each level
  theme_minimal() + # Use a minimal theme for a cleaner look
  theme(legend.position = "none") # Remove legend to avoid clutter

```
